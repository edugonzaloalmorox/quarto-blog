{
  "hash": "e3be477466afee9cc14a9bb403e3713f",
  "result": {
    "markdown": "---\ntitle: How to find a needle in a haystack using machine learning\nauthor: Edu Gonzalo-Almorox\ndate: '2023-10-17'\ntoc: true\ntoc-depth: 4\ntoc-title: Contents\nformat:\n  html:\n    code-fold: true\ncategories:\n  - ML\n  - GIS\nimage: images/location.jpg\n---\n\n![](images/solution.png)\n\nImagine you're a detective trying to track down a suspect in London. You have a few leads, but nothing concrete. One says the suspect was seen near the Bank of England. Another says it is near the Thames River. And a third says it may be within 3160 meters of a particular satellite path.\n\nCan you use machine learning to find the suspect? Yes, you can. You can do so by estimating the most likely point within a grid that reflects all possible locations where the suspect can be located.\n\nIn this blog I will show how to approach this problem from a machine learning perspective\n\n## Defining a grid\n\nFirst, we need to define a grid that covers all possible locations where the suspect could be. We can do this using a `meshgrid()` function in NumPy. This function creates a two-dimensional grid of points, where each point is defined by a pair of coordinates.\n\nWe can set the boundaries of the grid to be the coordinates of the River Thames, the Bank of England, and the satellite path. This will ensure that the grid covers all possible locations where the suspect could be.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np # for data manipulation \nfrom sklearn.ensemble import RandomForestRegressor   # for modelling \nfrom sklearn.multioutput import MultiOutputRegressor # for modelling \nfrom sklearn.metrics import mean_squared_error       # for evaluation\nfrom sklearn.model_selection import train_test_split # for modelling \nimport folium # for viz\n# Packages for functions -----------------------------------\nimport numpy as np\nfrom scipy.stats import norm, lognorm\nfrom sklearn.cluster import KMeans\nfrom sklearn.decomposition import PCA\nfrom sklearn.ensemble import RandomForestRegressor\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.multioutput import MultiOutputRegressor\nfrom sklearn.multioutput import MultiOutputClassifier\nfrom sklearn.pipeline import make_pipeline\nfrom sklearn.metrics import accuracy_score\n\n\nimport warnings\nwarnings.filterwarnings('ignore')\n\n\n\n\n# Define the set of coordinates ---------\nthames_coordinates = [\n    (51.489467, -0.236313), (51.468045, -0.216379),\n    (51.464141, -0.190458), (51.473257, -0.179515),\n    (51.480661, -0.173850), (51.484590, -0.148573),\n    (51.483601, -0.137501), (51.485793, -0.129604),\n    (51.494744, -0.122824), (51.508208, -0.118489),\n    (51.509330, -0.096431), (51.501904, -0.058365),\n    (51.508662, -0.043216), (51.506098, -0.030727),\n    (51.490202, -0.028796), (51.485098, -0.007725),\n    (51.490683, 0.000215), (51.502305, -0.005407),\n    (51.506552, 0.005536)\n]\n\n\nboe_coordinates = [51.514171,-0.088438]\n\nsat_path_coords = [(51.451000, -0.300000), (51.560000, 0.000000)]\n\n\n\n\n# Define the grid of points ---------------\nlon_min, lon_max = -0.1, -0.04\nlat_min, lat_max = 51.45, 51.55\n\nn_points = 500\nlons = np.linspace(lon_min, lon_max, n_points)\nlats = np.linspace(lat_min, lat_max, n_points)\nlon_grid, lat_grid = np.meshgrid(lons, lats)\n```\n:::\n\n\n## Calculate the distance\n\nOnce we have defined the grid, the next step is to calculate the distance from each point on the grid to each source of information. There are two types of distances we can use: `Haversine` distance and`Great Circle` distance.\n\nHaversine distance is the shortest distance between two points on a sphere. Great Circle distance is another type of distance we can use to calculate the distance between two points on a sphere. It's the shortest distance along the great circle, which is the imaginary circle that encircles the sphere and passes through the two points.\n\nWhich distance we use depends on the specific case. In the case of the Thames, which is a long, winding river, the shortest distance between two points on the river may not be the shortest distance between the two points on the grid.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\ndef haversine(lon, lat, coords):\n    \n    '''\n    Returns the haversine distance between a pair of coordinates and the coordinates of the grid\n    \n     Parameters\n    ------------\n        lon: int, Longitude of a point in the grid\n        lat: int, Latitude of a point in the grid\n        coords: tuple, Coordinates of the piece of information\n            \n    Return\n    -----------\n        distance : int\n            Difference between pair of coordinates and the coordinates of the grid \n    ''' \n    \n    lon1, lat1 = coords\n    R = 6371  # Earth radius in km\n    diff_lat = np.radians(lat1 - lat)\n    diff_lon = np.radians(lon1 - lon)\n    a = np.sin(diff_lat/2)**2 + np.cos(np.radians(lat1)) * np.cos(np.radians(lat)) * np.sin(diff_lon/2)**2\n    c = 2 * np.arctan2(np.sqrt(a), np.sqrt(1 - a))\n    distance = R * c\n    return distance\n```\n:::\n\n\nThe `Great Circle` distance, on the other hand, is another type of distance we can use to calculate the distance between two points on a sphere. It's the shortest distance along the great circle, which is the imaginary circle that encircles the sphere and passes through the two points.\n\nThis type of distance can be a good alternative in cases where there is not a clear trajectory between the points. In the case of the Thames which is a long, winding river, the shortest distance between two points on the river may not be the shortest distance between the two points on the grid.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\ndef great_circle_distance(lon, lat, coords):\n    \n    '''\n    Returns the great circle distance between a pair of coordinates and the coordinates of the grid\n    \n     Parameters\n    ------------\n        lon: int, Longitude of a point in the grid\n        lat: int, Latitude of a point in the grid\n        coords: tuple, Coordinates of the piece of information\n            \n    Return\n    -----------\n        distance : int\n            Difference between pair of coordinates and the coordinates of the grid \n    '''\n    \n    lon1, lat1 = coords[0]\n    lon2, lat2 = coords[1]\n    R = 6371  # Earth radius in km\n    diff_lat = np.radians(lat2 - lat1)\n    diff_lon = np.radians(lon2 - lon1)\n    a = np.sin(diff_lat/2)**2 + np.cos(np.radians(lat1)) * np.cos(np.radians(lat2)) * np.sin(diff_lon/2)**2\n    c = 2 * np.arctan2(np.sqrt(a), np.sqrt(1 - a))\n    distance = R * c\n    # Calculate the distance between each point on the grid and the great circle path\n    distance_to_path = np.abs(distance * np.sin(np.radians(lon) - np.radians(coords[0][0])))\n    return distance_to_path\n```\n:::\n\n\n### Calculate the probabilities\n\nOnce we have the distances from the suspect to each point on the grid, we need to calculate the probability of the suspect being at each point. To do this, we can use a statistical distribution, such as a `normal distribution` or a`lognormal distribution`.\n\nA normal distribution is bell-shaped, with the highest probability in the center and the probability decreasing as you move away from the center.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\n# Probability functions \ndef gaussian_prob(distance_to_thames):\n    '''\n    Returns a gaussian probability\n    \n     Parameters\n    ------------\n        distance_to_thames: int, distance (from the grid point) to thames (point)\n                \n    Return\n    -----------\n        pdf : int, probability distribution of the distance to thames\n            \n    '''\n\n    pdf = norm.pdf(distance_to_thames, loc=0, scale=2730)\n    return pdf\n\n\n\ndef normal_prob(distance_to_satellite_path):\n    '''\n    Returns a lognormal probability\n    \n     Parameters\n    ------------\n        distance_to_satellite: int, distance (from the grid point) to points of the satellite path\n                \n    Return\n    -----------\n        pdf : int, probability distribution of the distance to the satellite points of the path\n            \n    '''\n    pdf = norm.pdf(distance_to_satellite_path, loc=0, scale=3160)\n    return pdf\n```\n:::\n\n\nA lognormal distribution, on the other hand, is skewed to the right, with a few very high values and many lower values.\n\nThe type of distribution we use depends on the nature of the data. In the case of the Bank of England coordinates, which are likely to be skewed to the right, we might use a lognormal distribution.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\ndef lognormal_prob(distance_to_boe):\n    '''\n    Returns a lognormal probability\n    \n     Parameters\n    ------------\n        distance_to_boe: int, distance (from the grid point) to Bank of England (point)\n                \n    Return\n    -----------\n        pdf : int, probability distribution of the distance to Bank of England\n            \n    '''\n    pdf = lognorm.pdf(distance_to_boe, s=0.625, scale=np.exp(8.460))\n    return pdf\n\n```\n:::\n\n\nOnce we have calculated the probability of the suspect being at each point on the grid, we need to combine these probabilities to get a single probability distribution for the suspect's location.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\n#Calculate distances and probabilities to each source\n\n# THAMES -----------------------------------\n\n\ndistance_to_thames = np.zeros((n_points, n_points))\n\nfor i in range(len(lons)):\n    for j in range(len(lats)):\n        # Calculate the distance from each point on the grid to the Thames\n        # using the Haversine formula for spherical geometry\n        distance_to_thames[j, i] = haversine(lon_grid[j, i], lat_grid[j, i], thames_coordinates[0])\n\nprob_thames = gaussian_prob(distance_to_thames)\n\n# BANK OF ENGLAND  --------------------------------\n\ndistance_to_boe = np.sqrt((lon_grid - boe_coordinates[1])**2 + (lat_grid - boe_coordinates[0])**2)\nprob_boe = lognormal_prob(distance_to_boe) \n\n# SATELLITE ----------------------------------------\n\ndistance_to_satellite_path = great_circle_distance(lon_grid, lat_grid, sat_path_coords)\nprob_satellite = normal_prob(distance_to_satellite_path)\n\n```\n:::\n\n\n### Combine the probabilities for each point\n\nOnce we have calculated the probability of the suspect being at each point on the grid, we can combine these probabilities to get a single probability distribution for the suspect's location.\n\nOne way to combine probabilities is to use a stacking ensemble method. Stacking ensemble methods combine the predictions of multiple machine learning models to produce a more accurate prediction.\n\nIn this case, we can do this by training a Machine Learning method, `RandomForest()`, on the probabilities from the three sources of information to predict the (most likely) coordinates that compose the grid. Since this type of output is based on two elements (latitude and longitude), the random forest requires a `MultiOutputRegressor()`\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\n# Combine the three sets of probabilities into a single input array\nX = np.stack([prob_thames.flatten(), prob_boe.flatten(), prob_satellite.flatten()], axis=1)\n\n# Create the target array of grid points\nY = np.stack([lon_grid.flatten(), lat_grid.flatten()], axis=1)\n\n# Split the data into training and testing sets\n\n\nX_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2, random_state=42)\n\n# Create a multi-output RandomForestClassifier\n\nclf = RandomForestRegressor(n_estimators=100, random_state=42)\nmulti_clf = MultiOutputRegressor(clf)\n\n\n\n# Fit the classifier to the training data\nmulti_clf.fit(X_train, Y_train)\n\n\n# Predict the grid points for the test data\nY_pred = multi_clf.predict(X_test)\nrmse = np.sqrt(mean_squared_error(Y_test, Y_pred))\n\n\ndisplay(f\"The most likely location is {Y_pred[1]} and a root mean squared error (RMSE) on test set: {rmse:.4f}\")\n\n```\n\n::: {.cell-output .cell-output-display}\n```\n'The most likely location is [-0.0699982 51.4999544] and a root mean squared error (RMSE) on test set: 0.0239'\n```\n:::\n:::\n\n\nThe coordinates where the suspect is more likely to be are `[51.4999544, -0.0699982]`. Since we are running a regression model we can evaluate the results of the model on the basis of the Root Mean Square Error (RMSE) (`0.0239)`\n\n## Visualise the results\n\nOnce we have the predicted probabilities, we can visualize them using a library like `folium`. This will show us the most likely location of the suspect.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nlondon_coords = [51.509865, -0.118092]\nsuspect_coords = [51.4999544,-0.0699982]\nboe_coords = [51.514171,-0.088438]\n\nlondon_map = folium.Map(location=london_coords, zoom_start=12.5)\n\n\n\nfolium.Marker(\n    location= suspect_coords,\n    popup=\"Suspect likely location\",\n    icon=folium.Icon(color=\"red\"),\n).add_to(london_map)\n\nfolium.Circle(\n    radius=500,\n    location= suspect_coords,\n    popup=\"Suspect likely location\",\n    fill=False,\n).add_to(london_map)\n\n\nfolium.Marker(\n    location= boe_coords,\n    popup=\"Bank of England\",\n    icon=folium.Icon(color=\"green\", icon=\"building-columns\"),\n).add_to(london_map)\n\n\n\nlondon_map\n```\n\n::: {.cell-output .cell-output-display execution_count=32}\n```{=html}\n<div style=\"width:100%;\"><div style=\"position:relative;width:100%;height:0;padding-bottom:60%;\"><span style=\"color:#565656\">Make this Notebook Trusted to load map: File -> Trust Notebook</span><iframe srcdoc=\"&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    \n    &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;\n    \n        &lt;script&gt;\n            L_NO_TOUCH = false;\n            L_DISABLE_3D = false;\n        &lt;/script&gt;\n    \n    &lt;style&gt;html, body {width: 100%;height: 100%;margin: 0;padding: 0;}&lt;/style&gt;\n    &lt;style&gt;#map {position:absolute;top:0;bottom:0;right:0;left:0;}&lt;/style&gt;\n    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/leaflet@1.9.3/dist/leaflet.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;https://code.jquery.com/jquery-1.12.4.min.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/js/bootstrap.bundle.min.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/Leaflet.awesome-markers/2.0.2/leaflet.awesome-markers.js&quot;&gt;&lt;/script&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/leaflet@1.9.3/dist/leaflet.css&quot;/&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css&quot;/&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css&quot;/&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.0/css/all.min.css&quot;/&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/Leaflet.awesome-markers/2.0.2/leaflet.awesome-markers.css&quot;/&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/gh/python-visualization/folium/folium/templates/leaflet.awesome.rotate.min.css&quot;/&gt;\n    \n            &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,\n                initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot; /&gt;\n            &lt;style&gt;\n                #map_6eab50e4eadc30f73296a5bb4defcd23 {\n                    position: relative;\n                    width: 100.0%;\n                    height: 100.0%;\n                    left: 0.0%;\n                    top: 0.0%;\n                }\n                .leaflet-container { font-size: 1rem; }\n            &lt;/style&gt;\n        \n&lt;/head&gt;\n&lt;body&gt;\n    \n    \n            &lt;div class=&quot;folium-map&quot; id=&quot;map_6eab50e4eadc30f73296a5bb4defcd23&quot; &gt;&lt;/div&gt;\n        \n&lt;/body&gt;\n&lt;script&gt;\n    \n    \n            var map_6eab50e4eadc30f73296a5bb4defcd23 = L.map(\n                &quot;map_6eab50e4eadc30f73296a5bb4defcd23&quot;,\n                {\n                    center: [51.509865, -0.118092],\n                    crs: L.CRS.EPSG3857,\n                    zoom: 12.5,\n                    zoomControl: true,\n                    preferCanvas: false,\n                }\n            );\n\n            \n\n        \n    \n            var tile_layer_135e5b49c1a4015933fd202721a16568 = L.tileLayer(\n                &quot;https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png&quot;,\n                {&quot;attribution&quot;: &quot;Data by \\u0026copy; \\u003ca target=\\&quot;_blank\\&quot; href=\\&quot;http://openstreetmap.org\\&quot;\\u003eOpenStreetMap\\u003c/a\\u003e, under \\u003ca target=\\&quot;_blank\\&quot; href=\\&quot;http://www.openstreetmap.org/copyright\\&quot;\\u003eODbL\\u003c/a\\u003e.&quot;, &quot;detectRetina&quot;: false, &quot;maxNativeZoom&quot;: 18, &quot;maxZoom&quot;: 18, &quot;minZoom&quot;: 0, &quot;noWrap&quot;: false, &quot;opacity&quot;: 1, &quot;subdomains&quot;: &quot;abc&quot;, &quot;tms&quot;: false}\n            ).addTo(map_6eab50e4eadc30f73296a5bb4defcd23);\n        \n    \n            var marker_f16b213519998354d1870ab71e483555 = L.marker(\n                [51.4999544, -0.0699982],\n                {}\n            ).addTo(map_6eab50e4eadc30f73296a5bb4defcd23);\n        \n    \n            var icon_df1347a26d96c624485d88eb3825f1b0 = L.AwesomeMarkers.icon(\n                {&quot;extraClasses&quot;: &quot;fa-rotate-0&quot;, &quot;icon&quot;: &quot;info-sign&quot;, &quot;iconColor&quot;: &quot;white&quot;, &quot;markerColor&quot;: &quot;red&quot;, &quot;prefix&quot;: &quot;glyphicon&quot;}\n            );\n            marker_f16b213519998354d1870ab71e483555.setIcon(icon_df1347a26d96c624485d88eb3825f1b0);\n        \n    \n        var popup_35cc729d2610becdca3226d1cccaed56 = L.popup({&quot;maxWidth&quot;: &quot;100%&quot;});\n\n        \n            \n                var html_e25259d425419cbbd0aaeb2542c12633 = $(`&lt;div id=&quot;html_e25259d425419cbbd0aaeb2542c12633&quot; style=&quot;width: 100.0%; height: 100.0%;&quot;&gt;Suspect likely location&lt;/div&gt;`)[0];\n                popup_35cc729d2610becdca3226d1cccaed56.setContent(html_e25259d425419cbbd0aaeb2542c12633);\n            \n        \n\n        marker_f16b213519998354d1870ab71e483555.bindPopup(popup_35cc729d2610becdca3226d1cccaed56)\n        ;\n\n        \n    \n    \n            var circle_7b25fb1e6561ba6e1c386c3e4f036055 = L.circle(\n                [51.4999544, -0.0699982],\n                {&quot;bubblingMouseEvents&quot;: true, &quot;color&quot;: &quot;#3388ff&quot;, &quot;dashArray&quot;: null, &quot;dashOffset&quot;: null, &quot;fill&quot;: false, &quot;fillColor&quot;: &quot;#3388ff&quot;, &quot;fillOpacity&quot;: 0.2, &quot;fillRule&quot;: &quot;evenodd&quot;, &quot;lineCap&quot;: &quot;round&quot;, &quot;lineJoin&quot;: &quot;round&quot;, &quot;opacity&quot;: 1.0, &quot;radius&quot;: 500, &quot;stroke&quot;: true, &quot;weight&quot;: 3}\n            ).addTo(map_6eab50e4eadc30f73296a5bb4defcd23);\n        \n    \n        var popup_1dc821371a8379bd8fa507bd37f0286e = L.popup({&quot;maxWidth&quot;: &quot;100%&quot;});\n\n        \n            \n                var html_9b236de282ddc590a59fa064e4a0f7bc = $(`&lt;div id=&quot;html_9b236de282ddc590a59fa064e4a0f7bc&quot; style=&quot;width: 100.0%; height: 100.0%;&quot;&gt;Suspect likely location&lt;/div&gt;`)[0];\n                popup_1dc821371a8379bd8fa507bd37f0286e.setContent(html_9b236de282ddc590a59fa064e4a0f7bc);\n            \n        \n\n        circle_7b25fb1e6561ba6e1c386c3e4f036055.bindPopup(popup_1dc821371a8379bd8fa507bd37f0286e)\n        ;\n\n        \n    \n    \n            var marker_fc62c1e17722d07369c83838b6b0a2f7 = L.marker(\n                [51.514171, -0.088438],\n                {}\n            ).addTo(map_6eab50e4eadc30f73296a5bb4defcd23);\n        \n    \n            var icon_da3d043002a929d2f39e08db6869fe25 = L.AwesomeMarkers.icon(\n                {&quot;extraClasses&quot;: &quot;fa-rotate-0&quot;, &quot;icon&quot;: &quot;building-columns&quot;, &quot;iconColor&quot;: &quot;white&quot;, &quot;markerColor&quot;: &quot;green&quot;, &quot;prefix&quot;: &quot;glyphicon&quot;}\n            );\n            marker_fc62c1e17722d07369c83838b6b0a2f7.setIcon(icon_da3d043002a929d2f39e08db6869fe25);\n        \n    \n        var popup_a4a5cc2555c7ce04f623cacc3a3bbc30 = L.popup({&quot;maxWidth&quot;: &quot;100%&quot;});\n\n        \n            \n                var html_58b46ec68f2f4fd047703684bc83e7ee = $(`&lt;div id=&quot;html_58b46ec68f2f4fd047703684bc83e7ee&quot; style=&quot;width: 100.0%; height: 100.0%;&quot;&gt;Bank of England&lt;/div&gt;`)[0];\n                popup_a4a5cc2555c7ce04f623cacc3a3bbc30.setContent(html_58b46ec68f2f4fd047703684bc83e7ee);\n            \n        \n\n        marker_fc62c1e17722d07369c83838b6b0a2f7.bindPopup(popup_a4a5cc2555c7ce04f623cacc3a3bbc30)\n        ;\n\n        \n    \n&lt;/script&gt;\n&lt;/html&gt;\" style=\"position:absolute;width:100%;height:100%;left:0;top:0;border:none !important;\" allowfullscreen webkitallowfullscreen mozallowfullscreen></iframe></div></div>\n```\n:::\n:::\n\n\n## Conclusion\n\nIn this blog we have seen an example of how we can use machine learning to estimate a likely location in a map quickly and efficiently even in cases where there is limited information.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}